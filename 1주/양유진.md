# ch04. 변수

## 변수

프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, **저장된 값을 읽어 들여 재사용하기 위해** 변수라는 메커니즘을 제공한다. **변수는 “하나의 값을 저장하기 위해 확보한 메모리 공간 자체” or “그 메모리 공간을 식별하기 위해 붙인 이름”을 말한다.**

```jsx
var result = 10 + 20;
```

- **변수 이름(=식별자) :** 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름 (예제\_result)
  (+) ‘식별자’는 변수명 뿐 아니라 함수, 클래스 등의 이름
  즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름을 모두 가리킨다.
- **변수 값 :** 변수에 저장된 값 (예제\_30)
- **할당 :** 변수에 값을 저장하는 것
- **참조 :** 변수에 저장된 값을 읽어 들이는 것

❗️ **변수명(=식별자)**는 값 자체가 아닌, **메모리 주소를 저장**하는 것이다.

---

## 변수 선언

변수를 사용하기 위해 반드시 ‘선언’을 해야 한다. 변수를 선언할 때는 **var, let, const 키워드**를 사용한다.

**변수 선언**의 의미는 **변수 이름을 등록하고, 변수 값을 저장할 메모리 공간을 확보**한다는데 있다. 확보된 메모리 공간에는 자바스크립트 엔진에 의해 **‘undefined’값이 암묵적으로 할당**되어 **초기화**된다.

**var 키워드 단점**
→ var 키워드는 함수 레벨 스코프를 지원하는데, 이로 인해 개발자의 의도와 다르게 전역 변수가 선언 또는 재선언되는 심각한 부작용 발생의 위험이 있다.

![아직 선언한 적 없다는 거니… 당황하지 않아요.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/56554c85-c453-49cc-be74-1ea23289c85f/Untitled.png)

아직 선언한 적 없다는 거니… 당황하지 않아요.

만약, **선언하지 않은 식별자에 접근**하면 **ReferenceError(참조 에러)가 발생**한다. 참조 에러는 식별자를 통해 값을 참조하려 했으나, 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러이다.

---

## 변수 호이스팅

자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행된다.

```jsx
console.log(score); // undefined

var score; // 변수 선언문
```

따라서 위의 예제는 참조 에러가 발생할 것으로 보이지만, console.log(score)을 실행했을 때 주석 내용대로 ‘undefined’가 출력된다. 이는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아닌 그 이전 단계에서 먼저 실행되기 때문이다. 이처럼 **변수 선언문이 소스코드의 어디에 있든 선두로 끌어 올려진 것처럼 동작**하는 것은 **자바스크립트 고유 특징** 중 하나로, **변수 호이스팅**이라고 한다. 또한, 호이스팅은 변수 선언만이 아닌 var, let, const, function, class 등의 키워드를 사용해 선언하는 **모든 식별자에 해당**된다.

---

## 변수 값의 할당

변수에 값을 할당할 때는 할당 연산자 ‘=’를 사용하여 우변의 값을 좌변의 변수에 할당한다.

```jsx
console.log(score); // undefined

var score; // (1) 변수 선언
score = 80; // (2) 값의 할당
// var score = 80; 으로 변수 선언과 값의 할당을 하나의 문으로 단축 표현할 수 있다.

console.log(score); // 80
```

위 예제는 변수 선언과 값의 할당의 실행 시점이 다르다는 것을 설명하기 위한 내용이다. **변수 선언은 코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만, 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.** 변수 선언의 실행 시점과 변수 값 할당의 실행 시점의 차이를 주의하자.

### 값의 재할당

재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다.

```jsx
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당

// const 키워드
const foo = 10;
foo = 100; // TypeError 발생 _재할당X
```

var, let 키워드와 달리 **const 키워드는 값을 재할당 할 수 없어, 변수가 아닌 “상수(constant)”**라고 한다.

**(+) var, let, const 키워드 (유효 범위는 추후 정리 예정)**

|           | var            | let         | const       |
| --------- | -------------- | ----------- | ----------- |
| 유효 범위 | Function Scope | Block Scope | Block Scope |
| 재선언    | 가능           | 불가능      | 불가능      |
| 값 재정의 | 가능           | 가능        | 불가능      |

---

## 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 **문자, 숫자, 언더스코어(\_), 달러 기호($)**를 포함할 수 있다.
- 단, 식별자는 **숫자로 시작할 수 없다.** 특수문자를 제외한 문자, 언더스코어(\_), 달러 기호($)로 시작해야 한다.
- **예약어**(const, if, null, true, continue, …등등)는 식별자로 **사용할 수 없다.**
- 자바스크립트는 **대소문자를 구별**한다.
  (예: 변수명 firstname과 변수명 firstName은 각각의 변수로 인식한다.)
- 변수 이름은 변수의 존재 목적을 쉽게 알 수 있도록 **의미를 명확히 표현**해야 한다.
  (예: 변수 x는 변수가 의미하는 바를 알 수 없다. / 변수 score는 ‘점수’를 의미한다는 직관적인 뜻)
- 자바스크립트에서는 일반적으로
  - **변수, 함수 이름에 카멜 케이스**(예: camelCase, firstName)를 사용한다.
  - **생성자 함수, 클래스 이름에 파스칼 케이스**(예: PascalCase, FirstName)를 사용한다.

---

# ch05. 표현식과 문

## 값

**값(value)은 표현식이 평가되어 생성된 결과**를 말한다.

모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트(bit)의 나열로 저장된다.

---

## 리터럴

**리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법**을 말한다.

자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성한다.

| 리터럴             | 예시                     | 비고                  |
| ------------------ | ------------------------ | --------------------- |
| 정수 리터럴        | 100                      |                       |
| 부동소수점 리터럴  | 10.5                     |                       |
| 2진수 리터럴       | 0b01000001               | ‘0b’로 시작           |
| 8진수 리터럴       | 0o101                    | ES6 도입. '0o’로 시작 |
| 16진수 리터럴      | 0x41                     | ES6 도입. '0x’로 시작 |
| 문자열 리터럴      | 'Hello’, “World”         |                       |
| 불리언 리터럴      | true, false              |                       |
| null 리터럴        | null                     |                       |
| undefined 리터럴   | undefined                |                       |
| 객체 리터럴        | { name: ‘Lee’, age: 21 } |                       |
| 배열 리터럴        | [ 1, 2, 3 ]              |                       |
| 함수 리터럴        | function() {}            |                       |
| 정규 표현식 리터럴 | /[A-Z]+/g                |                       |

---

## 표현식

**표현식은 값으로 평가될 수 있는 문(statement)로, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조**한다. 리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등의 조합 역시 값으로 평가되므로 표현식이다.

```jsx
// 리터럴 표현식
10;
("Hello");

// 식별자 표현식 (선언이 이미 존재한다고 가정)
sum;
person.name;
arr[2];

// 연산자 표현식
10 + 20;
sum = 10;
sum !== 10;

// 함수/메서드 호출 표현식 (선언이 이미 존재한다고 가정)
square();
person.getName();
```

---

## 문

**문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위**이다. 문의 집합으로 이뤄진 것이 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다. **문은 여러 토큰으로 구성**되는데, **토큰(Token)이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미**한다. 예를 들어, 키워드, 식별자, 연산자 리터럴, 세미콜론(;)이나 마침표(.) 등의 특수기호는 문법적 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소이므로 모두 토큰이다.

### 문 종류

```jsx
// 변수 선언문
var x;

// 할당문
x = 10;

// 함수 선언문
function foo() {}

// 조건문
if (x > 1) {
  console.log(x);
}

// 반복문
for (let i = 0; i < 2; i++) {
  console.log(i);
}
```

### 표현식인 문 & 표현식이 아닌 문

**표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 “변수에 할당해 보는 것”이다.**

```jsx
// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
// 변수 선언 시, 암묵적으로 할당되는 undefined는 값으로 평가(X), 완료값(O)
var x;

// 1, 2, 1 + 2는 모두 표현식

// x = 1 + 2 는 표현식인 동시에 완전한 문
x = 1 + 2

// 표현식이 아닌 문은 값처럼 사용할 수 없다.
var foo = var x;   // SyntaxError: Unexpected token var

// 표현식인 문은 값처럼 사용할 수 있다.
var foo = x = 100;
```

---

# ch06. 데이터 타입

## 데이터 타입

데이터 타입은 값의 종류를 말하며, 자바스크립트(ES6)는 총 7개의 데이터 타입을 제공한다.

| 구분      | 데이터 타입      | 설명                                                |
| --------- | ---------------- | --------------------------------------------------- |
| 원시 타입 | 숫자 (number)    | 숫자. 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
|           | 문자열 (string)  | 문자열                                              |
|           | 불리언 (boolean) | 논리적 참(true)과 거짓(false)                       |
|           | undefined        | var 키워드로 선언된 변수에 암묵적으로 할당되는 값   |
|           | null             | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값   |
|           | 심벌 (symbol)    | ES6에서 추가됨                                      |
| 객체 타입 |                  | 객체, 함수. 배열 등                                 |

---

## 숫자 타입

자바스크립트는 **정수와 실수 구분 없이 ‘숫자(number)’ 타입만 존재**하며, **모두 ‘실수’로 처리**된다.
정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식(→ 8바이트)의 2진수로 저장된다. 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 별도로 제공하지 않기 때문에 이들 참조값은 모두 10진수로 해석된다.

```jsx
var integer = 10; // typeof(integer) => 'number'
var double = 10.12; // typeof(double) => 'number'
var negative = -20; // typeof(negative) => 'number'

var binary = 0b1000001; // 2진수
var octal = 0o101; // 8진수
var hex = 0x41; // 16진수
// 2진수, 8진수, 16진수 표기법은 다르지만, 참조값 출력은 모두 10진수로 동일하게 해석된다.
console.log(binary); // 65
console.log(octal); // 65
console.log(hex); // 65
console.log(binary === octal); // true
console.log(octal === hex); // true

// 숫자 타입의 세 가지 특별한 값
console.log(10 / 0); // Infinity
console.log(10 / -0); // -Infinity
console.log(1 * "String"); // NaN(= Not a Number)
```

## 문자열 타입

문자열 타입은 텍스트 데이터를 나타내는 데 사용하며, 작은따옴표(’’), 큰따옴표(””) 또는 백틱(``)으로 텍스트를 감싼다. 문자열을 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰과 구분하기 위해서이다.

```jsx
// 문자열 타입
var string;
string = "문자열"; // 작은따옴표
string = "문자열"; // 큰따옴표
string = `문자열`; // 백틱(ES6)

// 따옴표로 감싸지 않은 hello를 식별자로 인식한다.
var string = hello; // ReferenceError: hello is not defined
```

## 템플릿 리터럴 (ES6)

템플릿 리터럴은 **멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 보다 편리한 문자열 처리 기능을 제공**한다. 템플릿 리터럴은 **백틱(``)을 사용해 표현**하며, 런타임에 일반 문자열로 변환되어 처리된다.

### 멀티라인 문자열

줄바꿈이 허용되지 않는 일반 문자열과 달리, 템플릿 리터럴은 줄바꿈, 공백 등이 그대로 적용된다.

```jsx
// 일반 문자열 내에서는 줄바꿈이 허용X
var str = 'Hello
world';
// SyntaxError: Invalid or unexpected token

// 일반 문자열 내에서 줄바꿈 등의 공백을 표현하기 위해서는 "이스케이프 시퀀스" 사용해야 함
var template = '<ul>\n\t<li><a href="#">Home</a></li>\n</ul>';
console.log(template);
/*
[출력 결과]

<ul>
	<li><a href="#">Home</a></li>
</ul>
*/

// 템플릿 리터럴은 백틱(``) 사용으로 이스케이프 시퀀스 없이 줄바꿈, 공백 적용O
var template = `<ul>
	<li><a href="#">Home</a></li>
</ul>`;
// 출력 결과는 위와 동일
```

| 이스케이프 시퀀스 | 의미                                                                 |
| ----------------- | -------------------------------------------------------------------- |
| \0                | Null                                                                 |
| \b                | 백스페이스                                                           |
| \f                | 폼 피드: 프린터로 출력할 경우, 다음 페이지의 시작 지점으로 이동한다. |
| \n                | 개행: 다음 행으로 이동                                               |
| \r                | 개행: 커서를 처음으로 이동                                           |
| \t                | 탭(수평)                                                             |
| \v                | 탭(수직)                                                             |
| \uXXXX            | 유니코드. 예를 들어 ‘\u0041’은 ‘A’이다.                              |
| \’                | 작은따옴표                                                           |
| \”                | 큰따옴표                                                             |
| \\                | 백슬래시                                                             |

### 표현식 삽입

문자열은 + 연산자로 문자열 연산자를 연결했으나, **템플릿 리터럴 내에서는 ${}으로 표현식을 감싸주는 것**으로 간단히 표현식을 삽입할 수 있다. 이때 **표현식의 평가 결과가 문자열이 아니더라도 문자열로 타입이 강제 변환되어 삽입된다**는 점을 기억하자. 문자열 연산자보다 가독성 좋고 간편하게 문자열을 조합할 수 있어, 템플릿 리터럴 방식으로 표현식 삽입을 **권장**한다.

```jsx
var first = "Ung-mo";
var last = "Lee";

// 문자열 연결
console.log("My name is " + first + " " + last + ".");

// 템플릿 리터럴 표현식 삽입
console.log(`My name is ${first} ${last}.`);

// 출력 결과
// My name is Ung-mo Lee.
```

## 불리언 타입

불리언 타입의 값은 논리적 참, 거짓을 나타내는 **true, false** 뿐이다. 불리언 타입 값은 참/거짓으로 구분되는 조건에 의해 프로그램 흐름을 제어하는 **조건문에서 자주 사용**된다.

```jsx
var foo = true;
console.log(foo); // true

console.log(1 > 10); // false
```

## undefined 타입

개발자가 의도적으로 할당하기 위한 값이 아닌, **자바스크립트 엔진이 변수를 초기화할 때 사용하는 값**으로, undefined를 유일한 값으로 갖는다.

```jsx
var foo;
console.log(foo); // undefined
```

변수 선언 상태에서 참조하는 경우 undefined를 반환하는데, 이를 통해 방금 참조한 변수(예시: foo)가 개발자에 의해 초기화되지 않은 변수라는 것을 간파할 수 있다. ‘선언’ 상태가 아닌, 변수에 값이 없다는 것을 명시하고 싶은 경우에는 null을 할당한다.

## null 타입

프로그래밍 언어에서 null은 **변수에 값이 없다는 것을 의도적으로 명시할 때 사용**한다. 변수에 null을 할당하는 것은 **변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미**이며, 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다. 또한, **함수가 유효한 값을 반환할 수 없는 경우에도 명시적으로 null을 반환하기도 한다.**

## 심벌 (symbol) 타입 (ES6)

심벌 타입은 **다른 값과 중복되지 않는, 변경 불가능한 원시 타입의 값**이다. 따라서 주로 이름 충돌 위험이 없는 **객체의 유일한 프로퍼티 키(key)를 만들기 위해 사용**한다. 원시값은 리터럴을 통해 생성하지만, 심벌 타입은 **Symbol 함수를 호출해 생성**하는데, 이때 생성한 심벌값은 외부에 노출되지 않는다.

```jsx
// 심벌 값 생성
var key = Symbol("key");
console.log(typeof key); // symbol

// 객체 생성
var obj = {};

// 이름 충돌 위험 없는 유일무이한 값인 심벌을 프로퍼티로 사용한다.
obj[key] = "value";
console.log(obj[key]); // value
```

## 객체 타입

**자바스크립트는 객체 기반 언어**로, **자바스크립트를 이루고 있는 거의 모든 것이 객체**라는 것을 기억하자.

---

## 동적 타이핑

자바스크립트는 정적 타입 언어(예: C, C++, Java 등등)와 달리 변수 선언 시 타입을 선언하지 않는다. 자바스크립트의 변수는 데이터 타입 선언 대신, **할당하는 데이터 값의 타입에 따라 데이터 타입이 결정되며, 재할당에 의해 변수 타입은 언제든지 동적으로 변할 수 있다.** 이런 특징은 편리하지만, 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환될 수 있는 가능성이 있어 신뢰성은 다소 떨어진다. 따라서, **변수를 사용할 때 꼭 필요한 경우가 아니라면 가급적 상수를 사용하고, 전역 변수 사용은 자제하는 등 변수 사용에 주의가 필요**하다.

```jsx
var foo;
console.log(typeof foo); // undefined

foo = 3;
console.log(typeof foo); // number

foo = "Hello";
console.log(typeof foo); // string

foo = true;
console.log(typeof foo); // boolean

foo = null;
console.log(typeof foo); // object

foo = Symbol();
console.log(typeof foo); // symbol

foo = {};
console.log(typeof foo); // object

foo = [];
console.log(typeof foo); // object

foo = function () {};
console.log(typeof foo); // function
```
